;; Copyright (c) Daniel Borchmann. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file LICENSE at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns conexp.util.generators
  (:import [java.util.concurrent SynchronousQueue]
           [java.util NoSuchElementException]))

;;
;; Aim:
;;
;;  user=> (defg generator [x y]
;;           (dotimes [i x]
;;             (dotimes [j y]
;;               (yield (+ i j)))))
;;  #'user/generator
;;  user=> (def gen (generator 3 4))
;;  #'user/gen
;;  user=> (gen)
;;  0
;;  user=> (gen)
;;  1
;;  user=> (generate (generator 2 2))
;;  (0 1 1 2)
;;  user=>
;;

;; be aware of lazy sequences!
;; This does not work:
;;   (generate-by (fn runner [x]
;;                  (for [i (range x)]
;;                    (yield i)))
;;                100)
;;   -> ()
;; but this does:
;;   (generate-by (fn runner [x]
;;                  (doseq [i (range x)]
;;                    (yield i)))
;;                100)
;;   -> (0 1 2 3 ...)

;; Note: Normally generators are "function" returning different values
;; on different calls (hence they are not functions, actually). Here
;; generators are thought of as functions returning "functions" which
;; generate the different values. These functions also throw
;; NoSuchElementExceptions when there is nothing left to
;; generate. (See also iterators)

;; Generators

(defmacro make-generator
  "Creates a generator from the given function definition, which may
  use the function \"yield\". The result may be called with arguments
  to give a function returning all yielded values on subsequent
  calls."
  [function]
  `(fn [& args#]
     (let [^SynchronousQueue demand-queue# (SynchronousQueue.),   ; send demands to worker thread
           ^SynchronousQueue delivery-queue# (SynchronousQueue.), ; deliver results to consumer thread
           end# (atom false),
           eos# (Object.)]
       (letfn [(~(symbol "yield") [x#]
                (.put delivery-queue# x#)
                (.take demand-queue#))]
         (.start (Thread. (fn []
                            (.take demand-queue#)
                            (apply ~function args#)
                            (.put delivery-queue# eos#))))
         (fn []
           (let [next# (if @end#
                         eos#
                         (let [new# (do
                                      (.put demand-queue# 1)
                                      (.take delivery-queue#))]
                           (if (= new# eos#)
                             (reset! end# true))
                           new#))]
             (if @end#
               (throw
                (java.util.NoSuchElementException. "No more elements to generate."))
               next#)))))))

(defmacro defg
  "Globally def'ines a generator. When given some arguments a function
  is returned yielding all \"yield\"ed values on subsequent calls. See
  generate and use with care."
  [name args & body]
  `(defn ~name [& args#]
     (let [gen# (make-generator (fn ~name ~args ~@body))]
       (apply gen# args#))))

(defn generate
  "Collects all values generated by the generator into a lazy sequence.

  Example:

    (generate (generator 3 4))
    -> (0 1 2 3 1 2 3 4 2 3 4 5)

  with

    (defg generator [x y]
      (dotimes [i x]
        (dotimes [j y]
          (yield (+ i j)))))
  "
  [generator]
  (let [eos (gensym),
        runner (fn runner []
                 (lazy-seq
                  (let [next-elt (try
                                  (generator)
                                  (catch NoSuchElementException _
                                    eos))]
                    (if (= next-elt eos)
                      nil
                      (cons next-elt (runner))))))]
    (runner)))

(defmacro generate-by
  "Colletcs all values \"yield\"ed by the function. The definition of
  function may use the special function \"yield\" with an additional
  argument. All these values are than collected into a lazy sequence.

  Example:

    (generate-by (fn [x]
                   (doseq [i (range x)]
                     (yield i)))
                 5)
    -> (0 1 2 3 4)

  Note that you have to call yield explicitly. When you wrap a call to
  yield into a lazy sequence this call may not be done at all. For example

    (generate-by (fn [x]
                   (for [i (range x)]
                     (yield i)))
                 5)
    -> ()

  "
  [function & args]
  `(generate ((make-generator ~function) ~@args)))


;; Coroutines

;;
;; Aim:
;;
;; (defcor f []
;;   (dotimes [i 2]
;;     (dotimes [j 10]
;;       (println j))
;;     (yield-to g))
;;
;; (defcor g []
;;   (dotimes [i 2]
;;     (dotimes [j 10]
;;       (println (- 10 j)))
;;     (yield-to f)))
;;
;; Then (f) prints 0 .. 9, 10 .. 1, 0 .. 9, 10 .. 1.
;;
;; Leaving this by now as it is since I don't see any usage for this.

nil
